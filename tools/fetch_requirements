#!/bin/bash

#set -x
set -e

: "${WORK_DIR:=$HOME/.kni}"

if [ $# -ne 1 ]; then
    1>&2 echo "Fetches a blueprint's requirements (using the path specified on first argument).

Usage: $(basename $0) /path/to/requirements.yaml (relative to the current directory)"
    exit 1
fi

# check if requirements path exist
REQUIREMENTS_PATH="$(pwd)/$1"
if [ ! -e "${REQUIREMENTS_PATH}" ]; then
    1>&2 echo "Filename $REQUIREMENTS_PATH does not exist"
    exit 1
fi

mkdir -p "${WORK_DIR}"

function build_installer {
# Build an openshift-install binary from source.
# ARTIFACT is the name to be given to the binary.
# URL refers to the git repo to clone from.
# REF is the git ref to checkout.
    local ARTIFACT=$1
    local URL=$2
    local REF=$3

    TMP_DIR=$(mktemp -d)
    pushd "$TMP_DIR" > /dev/null
    export GOPATH=${TMP_DIR}/go
    mkdir -p "${GOPATH}/src/github.com/openshift"
    cd "${GOPATH}/src/github.com/openshift"
    git clone "${URL}"
    cd installer
    git checkout ${REF}
    TAGS=libvirt hack/build.sh
    mv bin/openshift-install ${WORK_DIR}/${ARTIFACT}
    popd > /dev/null
    /bin/rm -rf "$TMP_DIR"
}

function build_kustomize {
# Build a kustomize binary from source.
# ARTIFACT is the name to be given to the binary.
# URL refers to the git repo to clone from.
# REF is the git ref to checkout.
    local ARTIFACT=$1
    local URL=$2
    local REF=$3

    TMP_DIR=$(mktemp -d)
    pushd "$TMP_DIR" > /dev/null
    mkdir ${TMP_DIR}/go
    GOPATH=${TMP_DIR}/go go get -v sigs.k8s.io/kustomize
    mv go/bin/kustomize ${WORK_DIR}/${ARTIFACT}
    popd > /dev/null
    /bin/rm -rf "$TMP_DIR"
}

function fetch_requirement {
# Fetches the given binary (it can be openshift-install, oc, kubectl and
# kustomize).
# BINARY is the key of an entry in "requirements.yaml". It will be used
# to extract the specific binary from the specified url.
# URL and REF are parsed from the value in "requirements.yaml", which is
# assumed to be in "go-getter" format.
# (https://github.com/hashicorp/go-getter)
    local BINARY=$1
    local URL=${2%\?*}
    local REF=${2#*\?ref=}

    # extract tar.gz if exists
    BINARY_NAME=$(basename ${URL%\?*} .tar.gz)

    # flag it with -dev is it's a git repo
    if [[ "${BINARY_NAME}" == *.git ]]; then
        BINARY_NAME=${BINARY}-dev-${REF}
    fi

    # check if the binary already exists
    if [ -f "${WORK_DIR}/${BINARY_NAME}" ]; then
        1>&2 echo "Using existing ${WORK_DIR}/${BINARY_NAME}."
    else
        case "${URL}" in
            *.tar.gz )
                1>&2 echo "Pulling ${BINARY_NAME} tarball from ${URL}."
                TMP_DIR=$(mktemp -d)
                pushd "$TMP_DIR" > /dev/null
                curl -L ${URL} -o ${BINARY_NAME}.tar.gz
                tar -xf ${BINARY_NAME}.tar.gz

                # find the binary with the specified name and move it
                BINARY_PATH=$(find ./ -name ${BINARY} -print -quit)
                if [ ! -e "${BINARY_PATH}" ]; then
                    echo "${BINARY} not found in ${URL}"
                    exit
                fi
                mv ${BINARY_PATH} ${WORK_DIR}/${BINARY}
                popd > /dev/null
                /bin/rm -rf "$TMP_DIR"
                ;;
            *.git )
                1>&2 echo "Building ${BINARY} from ${URL}."
                local func_name="build_${binary}"
                $func_name ${BINARY_NAME} ${URL} ${REF}
                ;;
            * )
                1>&2 echo "Pulling ${BINARY} binary from ${URL}."
                curl -L ${URL} -o ${WORK_DIR}/${BINARY}
                chmod a+x ${WORK_DIR}/${BINARY}
                ;;
        esac
    fi
}


# Parses lines in "requirements.yaml" to fetch KV-pairs of
# profile names (or "kustomize" mapping to URLs to fetch the binaries/source
# from. URLs are expected to be in go-getter format.
# (https://github.com/hashicorp/go-getter)
while IFS="" read -r line || [ -n "$line" ]
do
    fetch_requirement ${line%: *} ${line#*: }
done <${REQUIREMENTS_PATH}
